"""
Unit Testing Planning

My thoughts for organizing API tests are to organize around the logical
objects that exist in the system (even if they don't yet exist physically).

- General
    [x] every valid request returns valid status
        - "status" key exists in the return object
        - "status" value == "ok"
    [ ] every invalid request returns a valid response
        - "status" and "msg" keys are present in return object
        - "status" value == "error"
        - "msg" needs to be greater than zero length

- Status
    [x] /status returns all the expected information
        - check all required keys to be present
        - status["status"] == "ok"

- Zones
    [x] valid zones
        [x] single zone on and off:   /zone/[1-7]/[on|off]
        [x] multiple zone on and off: /zone/[1-7]{2}/[on|off]
        [ ] "all" zones is a permitted zone to turn on or off
    [ ] invalid zone requested
    [x] extra zone request ignored
    [ ] invalid /zone URL returns error

- Schedule
    [ ] valid /schd request to run a zone for some number of minutes: /schd/<zone>[1-7]/<min>\\d+

- Cycles
    [x] /cycles returns successfully and yields the expected keys
        - bonus check is to see if a cycle is present, if its cycle complies with basic requirements
    [x] /cycles.text returns successfully
    [x] /cycle POST works to add a cycle
    [x] /cycle DELETE works to delete a cycle
    [ ] /cycle POST works to update a cycle
    [x] get against /cycle should return an error (as GET for this API doesn't make sense)
    [ ] get against /cycle/<name> should return a valid cycle
"""
import json
from random import randrange, choices
from time import sleep
from typing import Optional, Union

import inspect
import requests
import unittest


REQUIRED_CYCLE_KEYS = {'count', 'days', 'first', 'hour', 'min', 'name', 'schedule', 'type'}
# TEST_SERVER = "http://sp3"
TEST_SERVER = "http://192.168.7.65"  # this is the IP address of sptest.local


class TestBase(unittest.TestCase):
    @classmethod
    def setUpClass(cls) -> None:
        print(f"\n>>>>>>>>>> using test server {TEST_SERVER} <<<<<<<<<<\n")
        super().setUpClass()


class SprinklerAPITests(TestBase):
    def assert_cycles_identical(self, ref_cycle, found_cycle):
        for k in REQUIRED_CYCLE_KEYS:
            self.assertEqual(
                ref_cycle[k], found_cycle[k],
                f"expected reference {k} to equal found_cycle\n"
                f"ref_cycle={ref_cycle}\n"
                f"found_cycle={found_cycle}"
            )

    def construct_a_random_fully_built_out_cycle(self):
        """
        Returns a dict() containing a fully built-out Cycle Item.

        That is, the name is random and of maximum length, and all the other
        maximums, such as the number of Schedule items, are also maxed out.
        The idea is to fill up as much storage of a Cycle Item as possible.
        """
        schedule_items = [
            [[1], 15],
            [[3], 10],
            [[4], 15],
            [[5], 20],
            [[2, 6], 25],
            [[7], 15]
        ]
        cycle = {
            # name is constructed by adding an integer onto the string "Cycle"
            "name": f"Cycle {randrange(10000)}",
            "type": "specificDays",
            # days is generated by constructing a range of day numbers on the
            # range of 1 - 7, randomly long on the same range of 1 - 7
            "days": list(set(choices(range(1, 8), k=randrange(1, 8)))),
            "first": 1,
            "hour": randrange(24),
            "min": choices([0, 15, 30, 45])[0],
            "count": 1,
            # schedule is constructed by using choices(), which generates a
            # randomly long list of integers that can be no longer than the
            # number of schedule_items defined above
            "schedule": [
                schedule_items[n]
                for n in list(set(choices(range(len(schedule_items)), k=randrange(1, len(schedule_items)))))
            ]
        }
        return cycle

    def evaluate_api_response(self, result) -> dict:
        """
        Basic API response evaluation and conversion to a dict.

        :param result: the return from a requests invocation
        :return: dict of result.text
        """
        self.assertEqual(result.status_code, 200)

        status = json.loads(result.text)

        self.assertIn(status["status"], ["ok", "error"])

        # special test -- if status == "error" then there should also be a
        # "msg" key present with a non-zero length message

        if status["status"] == "error":
            self.assertTrue("msg" in status)
            self.assertTrue(len(status["msg"]) > 0)

        return status

    def evaluate_cycle(self, cycle):
        """Basic CycleItem evaluation to make sure required keys are present"""

        found_keys = set(cycle.keys())
        required_keys_not_found = REQUIRED_CYCLE_KEYS - found_keys

        if required_keys_not_found:
            print(f"required keys not found in first cycle: {required_keys_not_found}")

        self.assertEqual(len(required_keys_not_found), 0)

    def evaluate_status(self, status):
        """
        Evaluates basic integrity of the /status API
        """
        # the following keys ought to be in the /status API result
        required_keys = {"addr", "bootVersion", "chipId", "currCycle", "freeHeap", "freeSketchSpace", "hostname",
                         "logSize", "logicMode", "nextCycle", "numZones", "on", "outputEnable", "registers",
                         "resetReason", "rssi", "schedule", "scheduleSize", "schedulerState", "siRemaining",
                         "sketchSize", "startDateTime", "status", "time", "toggleDelay", "upTime", "adj",
                         "holdDays", "resume", "holdEpoch", "heapFragmentation", "availableDiskSpace",
                         "now", "scheduleItemEnd"}

        self.assertEqual(len(status.keys()), len(required_keys))

        found_keys = set(status.keys())
        required_keys_not_found = required_keys - found_keys

        if len(required_keys_not_found) > 0:
            print(f"required keys not found: {required_keys_not_found}")

        self.assertEqual(len(required_keys), len(found_keys))
        self.assertEqual(len(required_keys_not_found), 0)
        self.assertEqual(status["status"], "ok")

    def invoke_api(self, url: str, delay: Optional[int]=None) -> dict:
        """
        Invokes an API URL and does default initial tests to ensure that the
        server returned a success code (200) and that the status it reported
        back is okay.

        A built-in delay is included to slow down API calls such that there is
        a second delay before invoking so that invoking code need only concern
        itself with invoking the API.

        :param url: The full API URL string including hostname and http
        :param delay: (optional) Delay in seconds -- set to zero to inhibit
        :return: Returns the entire status JSON as a dict for further
            interrogation by the caller, if desired.
        """
        delay = 1 if delay is None else delay

        if delay:
            sleep(delay)

        result = requests.get(f"{TEST_SERVER}{url}")
        status = self.evaluate_api_response(result)

        return status

    def get_my_func_name(self):
        """
        Returns the name of the invoking function
        """
        return inspect.stack()[1][0].f_code.co_name

    def invoke_status(self, delay: int = None):
        status = self.invoke_api("/status", delay)

        self.evaluate_status(status)

        return status

    def invoke_zone_on(self, zones: Union[int, list]) -> dict:
        status = self.invoke_status(delay=0)

        if isinstance(zones, int):
            self.invoke_api(f"/zone/{zones}/on", 0)
            expected = status["on"] + [zones] if zones not in status["on"] \
                else status["on"]
        elif isinstance(zones, list):
            self.invoke_api(f"/zone/{','.join(map(str, zones))}/on")
            expected = status["on"] + [z for z in zones if z not in status["on"]]
        else:
            raise ValueError("invalid zones type:  must either be int or list")

        status = self.invoke_status(delay=1)
        self.assertEqual(set(status["on"]), set(expected))

        return status

    def invoke_zone_off(self, zones: Union[int, list]) -> dict:
        status = self.invoke_status(delay=0)

        def remove(a_list: list, from_list: list) -> list:
            """
            Remove items in a_list from from_list.

            :param a_list: a list of zones (ints) to remove
            :param from_list:  a list of zones
            :return: a list of zones that do not contain a_list
            """
            return list(filter(lambda i: i not in a_list, from_list))

        if isinstance(zones, int):
            self.invoke_api(f"/zone/{zones}/off", 0)
            expected = remove([zones], status["on"])
        elif isinstance(zones, list):
            self.invoke_api(f"/zone/{','.join(map(str, zones))}/off")
            expected = remove(zones, status["on"])
        else:
            raise ValueError("invalid zones type:  must either be int or list")

        status = self.invoke_status(delay=1)
        self.assertEqual(set(status["on"]), set(expected))

        return status


    def invoke_zone_all_off(self) -> dict:
        self.invoke_api("/zone/all/off", 0)

        status = self.invoke_status(delay=1)

        self.assertTrue(len(status["on"]) == 0)
        self.assertFalse(status["on"])

        return status

    def invoke_schd(self, zones: Union[int, list], run_time: int, no_verify: bool = False) -> dict:
        """
        Invoke the /schd/{}/{} API and execute tests that probe for a
        successful run.

        In order to verify that a schedule item was initiated correctly,
        and to make it possible for this method to function in any context,
        the tests are implemented relative to the status obtained directly
        before invoking the API.

        The things that should be affected by a successful initiation of a
        schedule item are:

        - "on": if "on" was originally empty, then "on" should be the length
        -   of the zones requested; otherwise, all we can say is that its
        -   length should be > 0 (because something should be running)
        - "schedule": the requested zones should be found in the schedule
        - "scheduleSize": this should be increased by the number of zones
        - "schedulerState": should be "running"
        - "siRemaining": should be the same as the run_time from the
        -   invocation, but only if the "on" list was originally empty;
        -   otherwise there's no telling what run_time to expect, but it
        -   would have to be greater than zero because some zone will be
        -   be running
        """

        before_status = self.invoke_status(delay=0)
        if isinstance(zones, int):
            z = str(zones)
            num_zones = 1
        else:
            z = ",".join(zones)
            num_zones = len(zones)

        self.invoke_api(f"/schd/{z}/{run_time}", delay=0)

        status = self.invoke_status()

        if no_verify:
            return status

        # length of "on" list should have increased by the number of zones
        if len(before_status["on"]) == 0:
            self.assertEqual(len(status["on"]), len(before_status["on"]) + num_zones)
        else:
            self.assertTrue(len(status["on"]) > 0)

        def flatten(x: Union[int, list]):
            for i in x:
                if isinstance(i, int):
                    yield i
                else:
                    yield from flatten(i)

        # the set of zones should be a subset of all zones in the schedule
        self.assertTrue(
            set([zones] if isinstance(zones, int) else zones)
                .issubset(set(list(flatten([si[0] for si in status["schedule"]]))))
        )
        self.assertEqual(status["scheduleSize"], before_status["scheduleSize"] + num_zones)
        self.assertEqual(status["schedulerState"], "running")

        if not before_status["on"]:
            self.assertEqual(status["siRemaining"], run_time)
        else:
            self.assertTrue(status["siRemaining"] > 0)

        return status

    def log_func_name(self, func_name):
        self.invoke_api(f"/debug/--- {func_name} ---", 1)

    def test_10_status_api(self):
        """
        Test basic /status API output

        The desire of this unit test function is to detect when I have made a
        change to the content of the /status API.  As of the writing of this
        function, I captured the keys from the JSON result and am going to 
        establish them as the baseline.  Whenever I run this test, it will
        ensure that I haven't made material changes to the output of this API.
        Stability in its output is essential because the UI will rely on it,
        and if keys change, the UI will mostly just silently go on without the
        value, and if it relies on it, will then produce unexpected results.
        If a new required key is introduced, add it to "REQUIRED_KEYS" at the
        beginning, and if a key changes (like I am sort of contemplating
        changing "siRemaining" to just "remaining" because who the heck knows
        what "si" means?  Even I am forgetting that it means "Scheduled Item",
        and anyway, that is the only thing that has the concept of 'remaining
        time'.  Zones and Cycles don't have that idea.)

        Otherwise, this test function ensures that /status responds with a
        successful status code, that result text is sent, that there are
        the right number of keys present, and then verifies each key name
        individually.
        """
        self.log_func_name(">>>>> SprinklerAPITests: start <<<<<")
        self.log_func_name(self.get_my_func_name())
        self.invoke_status(delay=0)

    def test_20_zones_1_basic(self):
        """Test basic /zone/{}/{} usage"""
        self.log_func_name(self.get_my_func_name())

        # todo - consider looking at outputEnable
        #   as part of this test, see if you can include interrogating
        #   outputEnable -- it should be "on", when a zone is on and
        #   "off" when all zones are off... and this might require a bit of a
        #   delay between /zone and interrogating /status -- I feel like I see a
        #   bit of visual delay between when I run the curl command and see the
        #   effect on the relay's LED.  The challenge I see here is that if the
        #   logic is set to "reversed" then I'm not sure if this will work.  I
        #   need to think about this more.

        # turn all zones off first, because if accidentally a zone were on when
        # this test fires, the Zone controller will allow it to stay on, but
        # when the "on" item is interrogated, it will return more than the
        # expected number of zones

        self.invoke_zone_all_off()
        self.invoke_zone_on(1)
        self.invoke_zone_off(1)

        # turning a different zone off that was never on should not result in
        # any error
        self.invoke_zone_off(2)

        # todo - other tests to write
        #   * test /zone/{}/toggle
        #       - there are all kinds of combos I can think of for this one, so it
        #         might be best to put it in its own test method
        #   * that said, maybe all of the above should be in their own methods
        #     so that more reporting appears when running the entire test suite

    def test_20_zones_2_two_zones(self):
        """
        Test turning two different zones on.

        Expectation is that the "on" list will contain the two zones, and only
        those two zones.
        """
        self.log_func_name(self.get_my_func_name())

        # ensure no zones are on
        status = self.invoke_status()
        self.assertFalse(status["on"])

        self.invoke_zone_on(3)
        status = self.invoke_zone_on(4)

        self.assertTrue(status["on"])
        self.assertEqual(len(status["on"]), 2)
        self.assertEqual(status["on"], [3, 4])

        status = self.invoke_zone_off(3)

        self.assertTrue(status["on"])
        self.assertEqual(len(status["on"]), 1)
        self.assertEqual(status["on"], [4])

        status = self.invoke_zone_off(4)

        self.assertFalse(status["on"])

    def test_20_zones_3_multiple_on_and_off(self):
        """
        Duplicate on and off of the same zone should be tolerated.
        """
        self.log_func_name(self.get_my_func_name())

        for n in range(2):
            self.invoke_zone_on(6)

        # a single "off" should work against two (erroneous) "on" requests
        self.invoke_zone_off(6)

        # turning on two zones simultaneously, then on singly should be ok
        self.invoke_zone_on([6, 7])
        self.invoke_zone_on(6)
        status = self.invoke_zone_on(7)

        # zones 6 & 7 should only be present in the "on" list once each, even
        # if they were turned on multiple times, using different APIs

        self.assertEqual(status["on"], [6, 7])

        # it should be possible to turn them both off simultaneously
        status = self.invoke_zone_off([6, 7])

        self.assertEqual(status["on"], [])

        # and finally, it should be tolerable to turn off zones that
        # aren't on, multiple times

        status = self.invoke_zone_off([6, 7])

        self.assertEqual(status["on"], [])

        self.invoke_zone_off(6)
        self.invoke_zone_off(7)
        self.invoke_zone_off([6, 7])

    def test_30_schedules_1_basics(self):
        """
        Ensure the /schd API works

        Boy howdy is there a lot to test here
        - get /schd/{}/{} to start a zone for a certain amount of time
        - another /schd/{}/{} start another zone
        - pause
        - resume
        - skip
        - cancel
        """
        self.log_func_name(self.get_my_func_name())

        # to start things out, let's get /status to obtain the number of zones
        # and then generate some random zone numbers to test with

        status = self.invoke_status(delay=0)
        num_zones = status["numZones"]

        # at the outset, the scheduler should be stopped and doing nothing
        self.assertEqual(status["schedulerState"], "stopped")

        # generate a couple of zones
        zone1, zone2 = [randrange(1, (num_zones + 1)) for i in range(2)]

        # turn the first zone on for 10 minutes

        self.invoke_schd(zone1, 10)

        # turn the second zone on with a different run time so that we can
        # look for it when we skip later in the test

        status = self.invoke_schd(zone2, 8)

        # make sure the zone number of each schedule item is the expected zone
        self.assertEqual({zone1, zone2}, set([si[0][0] for si in status["schedule"]]))

        # so little time should have passed that zone1's 10 minutes should
        # still be where "siRemaining" is at
        self.assertEqual(status["siRemaining"], 10)

        # pause the schedule -- this comes with a bunch of expectations
        #   1) the schedule should remain at size 2
        #   2) the "on" list of zones should be empty because none are on
        #   3) if "logicMode" is "normal", then "registers" ought to be 0, or
        #      if "reversed", then registers should be 255

        self.invoke_api("/schd/pause", 0)

        status = self.invoke_status()
        self.assertEqual(status["scheduleSize"], 2)
        self.assertFalse(status["on"])
        self.assertEqual(status["siRemaining"], 10)
        self.assertEqual(status["schedulerState"], "paused")

        if status["logicMode"] == "normal":
            self.assertEqual(status["registers"], 0)
        elif status["logicMode"] == "reversed":
            self.assertEqual(status["registers"], 255)
        else:
            self.assertIn(status["logicMode"], ["normal", "reversed"])

        # now let's resume

        self.invoke_api("/schd/resume", 0)
        status = self.invoke_status()

        self.assertEqual(status["scheduleSize"], 2)
        self.assertEqual(status["siRemaining"], 10)
        self.assertEqual(status["schedulerState"], "running")

        # make sure the zone number of each schedule item is the expected zone
        self.assertEqual({zone1, zone2}, set([si[0][0] for si in status["schedule"]]))

        # now let's skip and see if we move on to zone2

        self.invoke_api("/schd/skip", 0)

        # we have to wait a full 5 seconds to permit controller to move to
        # the next zone and allow for the inter-zone pause
        status = self.invoke_api("/status", 6)
        self.evaluate_status(status)

        self.assertEqual(status["scheduleSize"], 1)
        self.assertEqual(status["siRemaining"], 8)
        self.assertEqual(status["schedulerState"], "running")

        # make sure the zone number of each schedule item is the expected zone
        self.assertEqual({zone2,}, set([si[0][0] for si in status["schedule"]]))

        # next, let's cancel and make sure the scheduler stops doing everything

        self.invoke_api("/schd/cancel", 0)
        status = self.invoke_status()

        self.assertEqual(status["scheduleSize"], 0)
        self.assertEqual(status["siRemaining"], 0)
        self.assertEqual(status["schedulerState"], "stopped")
        self.assertFalse(status["on"])
        self.assertFalse(status["schedule"])

        # end the tests by turning everything off just in case (even so
        # /schd/cancel should have already turned everything off)

        self.invoke_zone_all_off()

        # finally, the schedule better still be empty (False)
        self.assertFalse(status["schedule"])

    def test_30_schedules_2_post_api(self):
        """
        Test the /schd/set API that permits setting of an entire schedule in
        one API call.

        This was originally implemented to permit me to execute schedules from
        my Raspberry PI, which functioned as my originally cycle controller
        until I could implement the Cycle Controller functionality directly in
        the ESP8266 software.

        - POST /schd/set (I wonder if this ought to just be post to /schd?)
            (this would be more in keeping with the other APIs I implemented
            subsequently, where a GET on the URL returns the current status
            and a POST sets a new value)
        - GET /schd/{}/{} while previous is still running => expect schedule
            item to be at the end of the "schedule" key
        now test the /schd/set POST API
        """

        ci = self.construct_a_random_fully_built_out_cycle()
        data = json.dumps({"schedule": ci["schedule"]})
        status = requests.post(f"{TEST_SERVER}/schd/set", data=data)

        self.assertEqual(status.status_code, 200)

        status = self.invoke_status()

        self.assertEqual(status["schedulerState"], "running")
        self.assertEqual(status["on"], ci["schedule"][0][0])
        self.assertEqual(status["schedule"], ci["schedule"])
        self.assertEqual(status["scheduleSize"], len(ci["schedule"]))
        self.assertEqual(status["siRemaining"], ci["schedule"][0][1])

        # cancel the schedule

        self.invoke_api("/schd/cancel", 0)
        status = self.invoke_status()

        self.assertEqual(status["scheduleSize"], 0)
        self.assertEqual(status["siRemaining"], 0)
        self.assertEqual(status["schedulerState"], "stopped")
        self.assertFalse(status["on"])
        self.assertFalse(status["schedule"])

    def test_40_testing_apis_10_download(self):
        """ Make sure /download on /cycles.json works """
        self.log_func_name(self.get_my_func_name())

        file_contents = requests.get(f"{TEST_SERVER}/download/cycles.json")

        self.assertTrue(file_contents.status_code, 200)

        file_dict = json.loads(file_contents.text)

        self.assertTrue("cycles" in file_dict)

        cycle_count = len(file_dict["cycles"])

        self.assertTrue(cycle_count > 0)

        if cycle_count > 0:
            for ci in file_dict["cycles"]:
                self.evaluate_cycle(ci)

    def test_40_testing_apis_20_up_ls_down_rm(self):
        """
        Test file maintenance APIS

        There are four file maintenance APIs:
        /ls - list files (returns human-readable text)
        /upload - puts a file up onto the board
        /download - copies a file contents to stdout (permitting the caller to
            write it to a local file system or capture it somehow in a buffer)
        /rm - remove a file
        """
        self.log_func_name(self.get_my_func_name())

        response = requests.get(f"{TEST_SERVER}/ls")

        # just test the status_code, don't call "evaluate_api_response()"
        # because it isn't JSON, but just text

        self.assertEqual(response.status_code, 200)

        # output returned ought to look like this:
        # Directory of /:
        # cycles.json
        # index.html
        #
        # Note that while "log.dat" probably will be present, it isn't an
        # absolute, so don't test that now.

        output = response.text.split("\n")
        orig_ls_len = len(output)

        self.assertEqual(output[0], "Directory of /:")
        self.assertTrue("cycles.json" in output)
        self.assertTrue("index.html" in output)

        if "test.txt" in output:
            self.invoke_api("/rm/test.txt", 0)
            orig_ls_len -= 1

        # create a file and upload it

        file_content = ["line 1", "line 2", "line 3 - eof"]
        file_text = "\n".join(file_content)
        files = {"file": ("test.txt", file_text)}
        response = requests.post(f"{TEST_SERVER}/upload", files=files)

        # note that only a 200 response code is sent, no JSON ok status message
        self.assertEqual(response.status_code, 200)

        # wild guess, but wondering if putting a second delay might help
        # with stability of the tests?  For some reason, this method often
        # causes the board to panic, and I'm not sure, but wondering if I am
        # pushing it too hard to ask for a /ls right after posting a file?

        sleep(1)

        # test.txt should now be present in a /ls

        response = requests.get(f"{TEST_SERVER}/ls")

        # again, can only check to make sure the status code indicates success
        self.assertEqual(response.status_code, 200)

        output = response.text.split("\n")
        ls_len_after_upload = len(output)

        self.assertTrue("test.txt" in output)
        self.assertTrue(ls_len_after_upload > orig_ls_len)

        # downloaded version should be identical to uploaded version

        response = requests.get(f"{TEST_SERVER}/download/test.txt")

        self.assertEqual(response.status_code, 200)
        self.assertEqual(file_text, response.text)

        # remove the file (and it does return a JSON response message, so the
        # call can use "invoke_api()" which checks status_code and "ok"
        # (reminder: the second "0" parameter means don't delay the invocation)

        self.invoke_api("/rm/test.txt", 1)

        # finally, "test.txt" should not be present in /ls output

        response = requests.get(f"{TEST_SERVER}/ls")

        self.assertEqual(response.status_code, 200)

        output = response.text.split("\n")
        ls_len_after_rm = len(output)

        self.assertFalse("test.txt" in output)
        self.assertEqual(ls_len_after_rm, orig_ls_len)

    def test_40_testing_apis_30_clear(self):
        """
        Ensure it is possible to fully replace and restore cycles

        This set of tests makes it possible to feel confident that we can
        swap out the existing cycles on the board with new ones that handle
        specific /cycle, /adj and /hold tests, screw around with them to
        our heart's content, and then successfully replace the cycles that
        where there originally and no one will know the wiser.

        This lets us test on a board (probably never the one deployed in the
        field) and do what we want, and leave no evidence of the tests once
        we are finished.

        It is expected that this will be a detailed test.  Subsequent tests
        will use the cycles.json swap out principle and not test the details
        because their focus will be on other functionality instead of
        cycles.json swapping.
        """
        self.log_func_name(self.get_my_func_name())

        # /download and retain the existing cycles.json file so that it
        # can be restored later
        response = requests.get(f"{TEST_SERVER}/download/cycles.json")

        self.assertEqual(response.status_code, 200)

        saved_cycles_text = response.text

        # save the result of /status to compare after restoring the file and
        # invoking /calc

        saved_status = self.invoke_api("/status", 0)

        self.evaluate_status(saved_status)

        # /clear should not kill the controller

        self.invoke_api("/clear", 0)

        # afterwards no next or current running cycle should be reported

        status_after_clear = self.invoke_api("/status", 1)

        # these are the items that I want to ensure are true when there is no
        # cycle defined at all -- the "initial state" of the controller

        self.evaluate_status(status_after_clear)
        self.assertTrue(len(status_after_clear["nextCycle"]) == 0)
        self.assertTrue(len(status_after_clear["currCycle"]) == 0)
        self.assertEqual(status_after_clear["startDateTime"], "none")
        self.assertTrue(len(status_after_clear["on"]) == 0)
        self.assertTrue(len(status_after_clear["schedule"]) == 0)
        self.assertEqual(status_after_clear["scheduleSize"], 0)
        self.assertEqual(status_after_clear["schedulerState"], "stopped")
        self.assertIn(status_after_clear["logicMode"], ["normal", "reversed"])

        if status_after_clear["logicMode"] == "normal":
            self.assertEqual(status_after_clear["registers"], 0)
        elif status_after_clear["logicMode"] == "reversed":
            self.assertEqual(status_after_clear["registers"], 255)

        self.assertEqual(status_after_clear["holdDays"], 0)

        # /upload cycles.json

        files = {"file": ("cycles.json", saved_cycles_text)}
        response = requests.post(f"{TEST_SERVER}/upload", files=files)

        self.assertEqual(response.status_code, 200)

        # incidentally, at this point, if we ask for the in-memory
        # representation of the cycles, it should still be empty, because
        # just uploading won't cause the controller to re-read the cycle
        # definitions in the json file

        cycles = self.invoke_api("/cycles.json", 0)

        self.assertTrue(len(cycles["cycles"]) == 0)

        # /deser should cause the cycles.json file to be re-read

        self.invoke_api("/deser", 0)

        # /calc should succeed - and returns status with "cycles" in it

        calc_status = self.invoke_api("/calc", 0)

        self.assertEqual(calc_status["nextCycle"], "Test")
        self.assertNotEqual(calc_status["startDateTime"], "none")

        # compare downloaded cycles.json to what comes back from the
        # /cycles.json API (and a reminder, this is NOT the file, but
        # rather the in-memory representation of the defined cycles)

        response = requests.get(f"{TEST_SERVER}/download/cycles.json")

        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.text, saved_cycles_text)

        # make sure the final status makes sense

        final_status = self.invoke_api("/status", 0)

        self.evaluate_status(final_status)
        self.assertEqual(saved_status["nextCycle"], final_status["nextCycle"])
        self.assertEqual(saved_status["startDateTime"], final_status["startDateTime"])

    def test_40_testing_apis_40_new_cycles(self):
        """Create new cycles and make sure we get them back identically"""
        self.log_func_name(self.get_my_func_name())

        # save the current cycles to restore at the end
        response = requests.get(f"{TEST_SERVER}/cycles.json")
        self.evaluate_api_response(response)
        saved_cycles_text = response.text

        # clear all cycles
        self.invoke_api("/clear", 0)

        # make new cycles
        new_cycle_1 = self.construct_a_random_fully_built_out_cycle()
        new_cycle_2 = self.construct_a_random_fully_built_out_cycle()

        # post them to the controller

        for ci in (new_cycle_1, new_cycle_2):
            response = requests.post(f"{TEST_SERVER}/cycle", json=ci)
            self.evaluate_api_response(response)

        # now get them back

        response = requests.get(f"{TEST_SERVER}/cycles.json")
        returned_cycles = self.evaluate_api_response(response)

        # let's make a dictionary out of the returned cycles with the name as
        # the key to facilitate comparison back to the originals

        returned_cycles_dict = {ci["name"]: ci for ci in returned_cycles["cycles"]}

        self.assertEqual(new_cycle_1, returned_cycles_dict[new_cycle_1["name"]])
        self.assertEqual(new_cycle_2, returned_cycles_dict[new_cycle_2["name"]])

        # finally restore the original cycles

        self.invoke_api("/clear", 0)
        files = {"file": ("cycles.json", saved_cycles_text)}
        response = requests.post(f"{TEST_SERVER}/upload", files=files)
        self.assertEqual(response.status_code, 200)
        self.invoke_api("/deser", 0)
        self.invoke_api("/calc", 0)

    def test_50_cycles_10_api(self):
        """
        Test the important contents of the /cycles API
        """
        self.log_func_name(self.get_my_func_name())

        cycles = self.invoke_api("/cycles", 0)

        required_keys = {"status", "cycles", "nextCycle", "startEpoch", "startDateTime", "time", "holdDays",
                         "holdEpoch"}
        found_keys = set(cycles.keys())
        required_keys_not_found = required_keys - found_keys
        
        if len(required_keys_not_found) > 0:
            print(f"required keys not found in /cycles: {required_keys_not_found}")

        self.assertEqual(len(required_keys), len(found_keys))
        self.assertEqual(len(required_keys_not_found), 0)

        # go one step further and test the first cycle's keys, if a cycle
        # happens to be present

        if cycles_list := cycles.get('cycles'):
            cycle = cycles_list[0]
            self.evaluate_cycle(cycle)
        else:
            print("no cycles to work with")

    def test_50_cycles_20_get(self):
        """
        Ensure that you can retrieve a single Cycle Item using /cycle/{}
        """
        self.log_func_name(self.get_my_func_name())

        # make sure a cycle exists
        ci = self.construct_a_random_fully_built_out_cycle()
        add_response = requests.post(f"{TEST_SERVER}/cycle", json=ci)

        self.evaluate_api_response(add_response)

        cycles_response = self.invoke_api("/cycles")

        self.assertTrue("cycles" in cycles_response)
        self.assertTrue(ci["name"] in [c["name"] for c in cycles_response["cycles"]])

        found_cycle = [c for c in cycles_response["cycles"] if c["name"] == ci["name"]][0]

        self.assert_cycles_identical(ci, found_cycle)

        # get rid of the cycle we created for this test
        del_response = requests.delete(f"{TEST_SERVER}/cycle", json={"name": ci["name"]})

        self.evaluate_api_response(del_response)

        cycles_response = self.invoke_api("/cycles")

        # the way this test works is to create a list comprehension of every
        # cycle returned by the API where the name equals the original Cycle
        # Item constructed in "ci".  The expectation is that **no** name will
        # match since we just requested to delete it.  So the list should be
        # empty, which evaluates to False.

        self.assertFalse(
            [c for c in cycles_response["cycles"] if c["name"] == ci["name"]],
            f"expected cycle '{ci['name']}' to have been deleted"
        )

    def test_50_cycles_30_api_text_output(self):
        """
        Test /cycles.text

        There's not much to test here.  Just invoke the API, make sure some-
        thing comes back, and maybe that the last line starts with the word
        "nextCycle:".
        """
        self.log_func_name(self.get_my_func_name())

        result = requests.get(f"{TEST_SERVER}/cycles.text")

        self.assertTrue(result)
        self.assertEqual(result.status_code, 200)
        self.assertTrue(len(result.text) > 0)

        lines = result.text.split("\n")

        self.assertTrue(len(lines) > 0)
        self.assertTrue(lines[-2].startswith("holdDays:"))

    def test_50_cycles_40_add_delete(self):
        """
        Ensure basic add/modify/delete works for a valid Cycle Item.
        """
        self.log_func_name(self.get_my_func_name())

        ci = self.construct_a_random_fully_built_out_cycle()

        # ensure the random cycle constructor produces a valid Cycle Item
        self.evaluate_cycle(ci)

        response = requests.post(f"{TEST_SERVER}/cycle", json=ci)
        added = self.evaluate_api_response(response)

        self.assertTrue("cycles" in added)
        cycles_length = len(added["cycles"])
        self.assertTrue(
            cycles_length > 0,
            f"expected at least 1 cycle, '{ci['name']}', to be present"
        )

        if cycles_length == 0:
            print("*** aborting rest of tests because Cycle Item was not created ***")
            return

        cycle_found = False
        for cycle_item in added["cycles"]:
            if ci["name"] == cycle_item["name"]:
                cycle_found = True
                self.evaluate_cycle(cycle_item)

        self.assertTrue(cycle_found, f"Cycle Item with name '{ci['name']}' not found")

        response = requests.delete(f"{TEST_SERVER}/cycle", json={"name": ci["name"]})
        deleted = self.evaluate_api_response(response)

        self.assertTrue("cycles" in deleted)

        # there should be 1 fewer cycle now than above

        self.assertEqual(len(deleted["cycles"]), cycles_length - 1)

        cycle_found = False
        for cycle_item in deleted["cycles"]:
            if ci["name"] == cycle_item["name"]:
                cycle_found = True

        self.assertFalse(cycle_found, f"failed to properly delete Cycle Item with name '{ci['name']}'")

    def test_50_cycles_50_invalid_values(self):
        """
        Ensure invalid cycle values are not permitted.

        This includes both invalid values, missing values but keys provided,
        missing keys all together.
        """
        self.log_func_name(self.get_my_func_name())

    def test_50_cycles_60_storage_capacity(self):
        """
        Ensure a reasonable number of Cycle Items can be stored and retrieved.

        Test to make sure some arbitrary number of cycles can be stored on
        board simultaneously to support whatever you think is a reasonable
        number of cycles.  Like let's say at least 6 of them.  Add cycles
        to get to the target number, then request the whole thing back and
        make sure there aren't any deserialization errors.
        """
        self.log_func_name(self.get_my_func_name())
        print("need to test storing at least 6 cycles")

    def test_50_cycles_70_updates_to_start_times(self):
        """
        Test updates to start times and days and ensure correct nextCycle.
        """
        self.log_func_name(self.get_my_func_name())

    def test_50_cycles_80_invalid_url(self):
        """
        Ensure that a request to /cycle is considered as invalid.
        """
        self.log_func_name(self.get_my_func_name())

        status = self.invoke_api("/cycle", 0)

        self.assertEqual(status["msg"], "not found: /cycle")

    def test_60_seasonal_adjustment_10_basic(self):
        """Ensure basic operation of /adj API"""
        self.log_func_name(self.get_my_func_name())

        adj_result = self.invoke_api("/adj")
        self.assertTrue("adj" in adj_result)
        self.assertTrue(adj_result["adj"].isnumeric())

        orig_adj = adj_result["adj"]

        # adding 9 to orig_adj should be a safe increment that is also unusual
        new_adj = int(orig_adj) + 9

        adj_result = self.invoke_api(f"/adj/{new_adj}")
        self.assertTrue("adj" in adj_result)
        self.assertTrue(adj_result["adj"].isnumeric())
        self.assertEqual(int(adj_result["adj"]), new_adj)

        # put adj back the way it was and test to make sure it got there
        adj_result = self.invoke_api(f"/adj/{orig_adj}")
        self.assertTrue("adj" in adj_result)
        self.assertTrue(adj_result["adj"].isnumeric())
        self.assertEqual(adj_result["adj"], orig_adj)

    def test_60_seasonal_adjustment_20_run_times_changed(self):
        """Ensure that run time change as expected with Seasonal Adjustment

        For this test, what I want to see is that when we set a non-100%
        Seasonal Adjustment, that the run times actually change when the
        cycle is started.  To do this, we'll define a custom Cycle Item and
        set up the schedule so that it has 1 zone that runs for 10 minutes.
        Then we'll set the Seasonal Adjustment to 50, initiate the cycle
        and probe /status to see if the actual run time set for that cycle
        is only 5 minutes.  If so, we'll cancel the cycle, return /adj to
        whatever it was to begin with and then delete the cycle.

        Important note:  the delay values set on the various invoke_api()
        calls are important to keep as they are.  In some cases, the
        existing implementation of the API includes a delay, so if we
        probe too soon for /status, we may not get back the expected
        values.
        """
        self.log_func_name(self.get_my_func_name())

        # get the current /adj value (Seasonal Adjustment)
        orig_adj_result = self.invoke_api("/adj", 0)

        # set the current /adj to 50
        self.invoke_api("/adj/50", 0)

        # create a custom cycle
        ci = self.construct_a_random_fully_built_out_cycle()

        # change the cycle's schedule to just zone 1 with 10 minutes
        ci["schedule"] = [[[1], 10]]

        # add the cycle
        response = requests.post(f"{TEST_SERVER}/cycle", json=ci)
        self.evaluate_api_response(response)

        # now get the cycle back

        # manually start the cycle
        result = self.invoke_api(f"/cycle/{ci['name']}/run", 0)
        self.assertEqual(f"cycle started: {ci['name']}", result["msg"])

        # get /status
        result = self.invoke_api("/status", 1)
        self.evaluate_status(result)

        # we should see the run time be 5 minutes
        self.assertEqual(5, result["schedule"][0][1])

        # cancel the cycle
        self.invoke_api(f"/schd/cancel", 0)

        # set /adj to 100
        self.invoke_api("/adj/100", 0)

        # start the cycle
        self.invoke_api(f"/cycle/{ci['name']}/run", 1)

        # get /status
        result = self.invoke_api("/status", 0)
        self.evaluate_status(result)

        # we should see the run time be 10 minutes
        self.assertEqual(10, result["schedule"][0][1])

        # cancel the cycle
        self.invoke_api(f"/schd/cancel")

        # delete the cycle
        response = requests.delete(f"{TEST_SERVER}/cycle", json={"name": ci["name"]})
        self.evaluate_api_response(response)

        # reset /adj to what it was to begin with
        self.invoke_api(f"/adj/{orig_adj_result['adj']}", 0)

        # check to make sure that the cycle is gone -- use the /cycle/{} API
        # and anticipate receiving back "status" == "error"
        response = requests.get(f"{TEST_SERVER}/cycle/{ci['name']}")
        self.assertEqual(200, response.status_code)

        result = json.loads(response.text)
        self.assertEqual(result["status"], "error")
        self.assertEqual(result["msg"], "cycle not found")

    def test_70_system_hold_10_basic(self):
        """Test basic /hold API operation"""
        self.log_func_name(self.get_my_func_name())

        # todo - set and get values
        #   - capture initial value so that it can be restored at end of test
        #   - set up a cycle with Mon,Wed,Fri run times and then based on whatever
        #     today is, figure out how to test weird situations
        #   - might need to make this test change dynamically based on what today is
        #       - for example, if today is Mon, Wed or Fri, then make the cycle
        #         Tue, Thu or vice versa
        #       - expectations will have to be calculated based on what today is
        #   - set up will of course entail swapping out the existing cycles on the
        #     board for special ones designed to verify hold functionality

    def test_70_system_hold_20_advanced(self):
        """Advanced tests of /hold API to ensure cycles delay properly"""
        self.log_func_name(self.get_my_func_name())

    def test_99_end(self):
        self.log_func_name(">>>>> SprinklerAPITests: end <<<<<")


if __name__ == "__main__":
    # set verbosity=2 to generate output of function name output first comment
    unittest.main(verbosity=2)